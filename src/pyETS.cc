#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/complex.h>

#include "string_utils.h"
#include "ets.h"
#include "ets_helpers.h"

using namespace std;

namespace {

namespace py = pybind11;

py::list getAllCobras()
  {
  auto c=makeCobras();
  auto ncb = c.size();
  auto res = py::list();
  for (size_t i=0; i<ncb; ++i)
    {
    auto tmp = py::list();
    tmp.append(py::cast(complex<double>(c[i].center)));
    tmp.append(py::cast(c[i].l1));
    tmp.append(py::cast(c[i].l2));
    tmp.append(py::cast(complex<double>(c[i].dotpos)));
    tmp.append(py::cast(c[i].rdot));
    res.append(tmp);
    }
  return res;
  }

map<size_t,vector<size_t>> getVis(const vector<complex<double>> &t_pos,
  const py::list &cbr)
  {
  vector<Target> tgt;
  for (size_t i=0; i<t_pos.size(); ++i)
    tgt.emplace_back(t_pos[i],1.,1);

  vector<Cobra> cobras;
  for (auto i:cbr)
    {
    planck_assert(i.cast<py::list>().size()==5,"format mismatch");
    cobras.emplace_back(i[py::cast(0)].cast<complex<double>>(),
                        i[py::cast(1)].cast<double>(),
                        i[py::cast(2)].cast<double>(),
                        i[py::cast(3)].cast<complex<double>>(),
                        i[py::cast(4)].cast<double>());
    }
  auto tmp = getT2F(tgt,cobras);
  map<size_t,vector<size_t>> res;
  for (size_t i=0; i< tmp.size(); ++i)
    if (tmp[i].size()>0) res[i]=tmp[i];
  return res;
  }

map<size_t,size_t> getObs(const vector<complex<double>> &t_pos,
                          const vector<double> &t_time,
                          const vector<int> &t_pri,
                          const py::list &cbr,
                          const string &assigner)
  {
  planck_assert((t_pos.size()==t_time.size())
              &&(t_pos.size()==t_pri.size()), "vector length mismatch");
  vector<Target> tgt;
  for (size_t i=0; i<t_pos.size(); ++i)
    tgt.emplace_back(t_pos[i],t_time[i],t_pri[i]);

  vector<Cobra> cobras;
  for (auto i:cbr)
    {
    planck_assert(i.cast<py::list>().size()==5,"format mismatch");
    cobras.emplace_back(i[py::cast(0)].cast<complex<double>>(),
                        i[py::cast(1)].cast<double>(),
                        i[py::cast(2)].cast<double>(),
                        i[py::cast(3)].cast<complex<double>>(),
                        i[py::cast(4)].cast<double>());
    }

  vector<size_t> tid, fid;
  if (!tgt.empty())
    getObservation(tgt,cobras,assigner,tid,fid);
  map<size_t,size_t> res;
  for (size_t i=0; i<tid.size(); ++i)
    res[tid[i]] = fid[i];
  return res;
  }

} // unnamed namespace

PYBIND11_MODULE(pyETS,m)
  {
  using namespace pybind11::literals;
  m.doc() = "Python interface for some of the ETS C++ functionality";
  m.def("getVis", &getVis,
    "returns a list of the visible targets and the fibers that can observe them.\n"
    "Args:\n"
    "  t_pos  : Target x/y coordinates on the focal plane (in mm)\n"
    "  cbr    : list of cobras as generated by getAllCobras()\n"
    "t_pos"_a, "cbr"_a);
  m.def("getObs", &getObs,
    "performs an assignment step and returns a dictionary containing the\n"
    "observed target numbers and the assigned cobra numbers\n"
    "Args:\n"
    "  t_pos   : Target x/y coordinates on the focal plane (in mm)\n"
    "  t_time  : requested target observation times (in seconds) (unused)\n"
    "  t_pri   : target priorities\n"
    "  cbr     : list of cobras as generated by getAllCobras()\n"
    "  assigner: algorithm to do the assignment. Must be one of 'naive',"
    "            'draining', 'draining_closest' or 'new'\n",
    "t_pos"_a, "t_time"_a, "t_pri"_a, "cbr"_a, "assigner"_a);
  m.def("getAllCobras", &getAllCobras,
    "returns a list containing the parameters of all cobras of an idealized \n"
    " instrument configuration. The parameters are in turn stored as\n"
    " 5-element lists of numbers (unit is mm):\n"
    "  cobra center (complex)\n"
    "  length l1 (link between center of cobra and 'elbow')\n"
    "  length l2 (link between 'elbow' and tip\n"
    "  dot position (complex)\n"
    "  dot radius");
  }
